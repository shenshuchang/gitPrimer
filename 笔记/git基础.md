---
typora-root-url: assetis
---

#    														git基础

# 1、git是什么？



Git是目前世界上最先进的分布式版本控制系统（没有之一）。

Git有什么特点？简单来说就是：高端大气上档次！



#### 什么是版本控制：

如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：

朦胧诗

想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：

![](/../0.jpg)

过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，**真麻烦。**



看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，**真郁闷**。

更要命的是，有些部分需要你的财务同事帮助写一部分，于是你把文件Copy到U盘里给她，然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，**真困难**。

![u=4066774319,2960151406&fm=26&gp=0](/u=4066774319.jpg)

于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是**很方便**？

这个软件用起来就应该像这个样子，能记录每次文件的改动：

![image-20210330210751895](/image-20210330210751895.png)

![img](/u=3182037040,3330670984&fm=26&gp=0.jpg)

这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。

![](/u=2749652787,570074112&fm=26&gp=0.jpg)



创建版本库
版本迭代
版本回滚
管理修改
创建远程仓库
创建分支

# 2、版本管理工具的分类



#### 1.svn （集中式）

集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。



![](/../format.png)

集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。



![](/../u=1597617972,825005697&fm=26&gp=0.jpg)

#### 2.git(分布式)

分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。

和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。

![img](/d.jpg)

在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。



![img](.\format11.png)

# 3、下载git

#### 1、下载地址：

https://git-scm.com/

http://npm.taobao.org/mirrors/git-for-windows/



<img src="/image-20210330212248107.png" alt="image-20210330212248107" style="zoom:80%;" />



下载后得到一个安装包：

![image-20210330212726646](/image-20210330212726646.png)





#### 2、安装：

默认安装（傻瓜式下一步下一步）

#### 3、安装成功：

1.win+r  调出运行窗口      
2.输入cmd  调出命令行工具（终端）
3.输入 git  --version  显示git版本号，表示git安装成功   

<img src="/image-20210330213526230.png" alt="image-20210330213526230" style="border: 1px solid rgb(153, 153, 153);padding:5px" />

# 4、使用git



#### 1、创建版本库

什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。

所以，创建一个版本库非常简单

1.首先，选择一个合适的地方，创建一个空目录：
例如文件名为 QY133_NB的文件夹,里面可以随便放一些文件，文件等等

![image-20210330214636682](/image-20210330214636682.png)

2.通过 git init 命令把这个目录变成Git可以管理的仓库：

![image-20210330214828413](/image-20210330214828413.png)

<img src="/image-20210330214851125.png" alt="image-20210330214851125" style="zoom:80%;border: 1px solid #999" />

进入文件目录后，输入git init,生成git可以管理的仓库：



<img src="/image-20210330215019925.png" alt="image-20210330215019925" style="zoom:80%;border: 1px solid #999" />



瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的大聪明可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。

![image-20210330215109886](/image-20210330215109886.png)

如果没有看见这个文件夹，因为.git文件夹是隐藏的文件夹，可以通过查看，勾选隐藏的项目勾选出来

![image-20210330215256334](/C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210330215256334.png)







**第二种创建方法：**

在需要创建git版本库的文件夹下

按shift键后右键

点击 在此处打开Powershell 窗口（s）

<img src="/image-20210330215935367.png" alt="image-20210330215935367" style="zoom: 80%;" />

输入 git init 命令，同样可以创建git版本库 

![image-20210330220143633](/image-20210330220143633.png)



**第三种方法：**

<img src="/image-20210330220744830.png" alt="image-20210330220744830" style="zoom:80%;" />

在vscode文件夹下，右键，在集成终端打开，输入 git init命令即可





#### 3、常规开发项目

创建项目，正常写代码
代码一定要放到**git仓库**目录下，因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。



#### 4、提交到本地仓库

- 第一步：git status 检查版本库的状态

  

  <img src="/image-20210330221741875.png" alt="image-20210330221741875" style="zoom:80%;border: 1px solid #999" />

  

- 第二步，用命令git add <file>告诉Git，把文件添加到仓库
  git add **.**    提交全部【注意，后面带点  git  空格 add 空格 点】

- 第三步，用命令git commit -m '提交说明'告诉Git，把文件提交到仓库

- 第四步，提交时，会提示配置用户
  git config --global user.name  ‘username’            //username是你的git账号 
  git config --global user.email  ‘email ‘                   //email是你的git邮箱



<img src="/image-20210330224254069.png" alt="image-20210330224254069" style="zoom:80%;border: 1px solid #999;padding:5px" />

如果提示让输入用户名，接下来输入命令：



```
git config --global user.email "473203063@qq.com"
git config --global user.name "陈福国"
```

<img src="/image-20210330224407968.png" alt="image-20210330224407968" style="zoom:80%;border: 1px solid #999" />

![image-20210330225311687](/image-20210330225311687.png)



工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库

Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。



#### 5、初始化一个Git仓库，使用git init命令。

添加文件到Git仓库，分两步：

1. 使用命令git add <file>，注意，可反复多次使用，添加多个文件；
2. 使用命令git commit -m ‘message’，完成。

<img src="/image-20210330231235807.png" alt="image-20210330231235807" style="zoom:80%;border:1px solid #999" />

#### 6、版本回退



金庸群侠传

存档

你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。



![img](/u=1017698937,3714421239&fm=26&gp=0.jpg)



当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用`git log`命令查看：



**在Git中，我们用git log命令查看，提交的历史记录**

<img src="/image-20210330233610619.png" alt="image-20210330233610619" style="zoom:80%;border:1px solid #999" />

#### 7、回退

现在我们启动时光穿梭机，准备把 `index.html` 回退到上一个版本，也就是`第三次添加10个li标签`的那个版本，怎么做呢？



首先，Git必须知道当前版本是哪个版本，在Git中，用`HEAD`表示当前版本，也就是最新的提交`6d20e733...`（注意我的提交ID和你的肯定不一样），上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。

现在，我们要把当前版本`第四次添加类名four的divb标签`回退到上一个版本`第三次添加10个li标签`，就可以使用`git reset`命令：

```
git reset --hard HEAD^
```

![image-20210330234708106](/image-20210330234708106.png)

<img src="/image-20210330235151900.png" alt="image-20210330235151900" style="zoom:80%;border:1px solid #999;padding:5px" />



代码也会跟着自动的更新，会回到第三次状态时的代码

#### 8、后悔药

回退的过分了，后悔了。只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个某个版本的commit id是33d9d598d123bb1327ba2abd9b73b725000abd9c，于是就可以指定回到未来的某个版本：
git reset --hard 33d9d598d
版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。



<img src="/image-20210330235936802.png" alt="image-20210330235936802" style="zoom:80%;border:1px solid #999;padding:5px" />



如果命令行已经关闭了，怎么办呢？？记不住版本号了吧？



![](/../22365.png)



Git提供了一个命令git reflog用来记录你的每一次命令：

<img src="/image-20210331000344544.png" alt="image-20210331000344544" style="zoom:80%;border:1px solid #999;padding:10px" />





# 5、远程仓库（GitHub）

Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。

你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？

实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。

完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。

#### 1、注册账号

1.自行注册GitHub账号

登陆后界面：

![image-20210331003653066](/image-20210331003653066.png)



#### 2、新建一个远程仓库



<img src="/image-20210331003919064.png" alt="image-20210331003919064" style="zoom:80%;" />



![image-20210331004305725](/image-20210331004305725.png)



![image-20210331004930417](/image-20210331004930417.png)







![image-20210331005407851](/image-20210331005407851.png)





##### 2.本地Git仓库和GitHub仓库之间的传输是通过SSH加密，查看秘钥

Git bash 下查看 ，右键，点击Git Bash Here

![image-20210331005718068](/image-20210331005718068.png)



> ls -al ~/.ssh                                       检查ssh keys是否存在

此命令窗口 不支持ctrl+v粘贴  需要右键 点击 paste

如图：表示不存在秘钥

![image-20210331010032546](/image-20210331010032546.png)





> ssh-keygen -t rsa -C ''xxx''                添加一个ssh 



![image-20210331011103692](/image-20210331011103692.png)



![image-20210331011314713](/image-20210331011314713.png)



ssh-add ~/.ssh/id_res                        生成新的key
-t = The type of the key to generate
    密钥的类型
    -C = comment to identify the key
    用于识别这个密钥的注释
    So the Comment is for you only and you can put anything inside.
    Many sites and software are using this comment as the key name.
    所以这个注释你可以输入任何内容，很多网站和软件用这个注释作为密钥的名字





**本地管理员目录会出现一个.ssh文件夹**



里面有id_rsa和id_rsa.pub两个文件，

这两个就是SSH Key的秘钥对，

id_rsa是私钥，不能泄露出去，

id_rsa.pub是公钥，可以放心地告诉任何人。

![image-20210331011637660](/image-20210331011637660.png)



登陆GitHub，打开“Account settings”，“SSH Keys”页面：

<img src="/image-20210331011945882.png" alt="image-20210331011945882" style="zoom:80%;" />

​		点击new SSH key

![image-20210331012106977](/image-20210331012106977.png)





然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：

![image-20210331012359843](/image-20210331012359843.png)

​	

> ssh -T git@github.com   检测是否建立连接成功





![image-20210331012754894](/image-20210331012754894.png)




--------------------------------------------------------------------------------
显示该内容，表示不成功

 ![image-20220519095850743](/image-20220519095850743.png)

如果不成功

```
https://blog.csdn.net/nightwishh/article/details/99647545
```

![image-20220519100815051](/image-20220519100815051.png)



```
Host github.com
User 473203063@qq.com
Hostname ssh.github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa
Port 443

```



 ![image-20220519104636589](/image-20220519104636589.png)

> :wq 保存退出



为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。
当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。
最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。

如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。



#### 2、添加到远程仓库

1.创建远程仓库
2.本地仓库添加到远程仓库





点击要提交的远程仓库：

![image-20210331014028134](/image-20210331014028134.png)



![image-20210331014227241](/image-20210331014227241.png)



<img src="/image-20210331110928257.png" alt="image-20210331110928257" style="zoom:80%;border:1px solid #999;padding:5px" />

把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。
由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。

![image-20210331015241537](/image-20210331015241537.png)

从现在起，只要本地作了提交，就可以通过命令：
git push origin master



#### 3、GitHub Pages

<img src="/image-20210331203317800.png" alt="image-20210331203317800" style="zoom:80%;" />



![image-20210331203417211](/image-20210331203417211.png)

![image-20210331203436551](/image-20210331203436551.png)







# 6、克隆远程仓库

上面，我们讲了先有本地库，后有远程库的时候，如何关联远程库。
现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。
首先，登陆GitHub，创建一个新的仓库，名字叫xxx：
现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：



登陆gitHub,点进项目，选择code,选择ssh,复制地址，当前地址就是我们克隆项目的地址

![image-20210331204822223](/image-20210331204822223.png)

> git@github.com:cfg1573/test_QY133.git

> git@github.com:cfg1573/QY135Nb666.git

如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。

1、新建文件夹，输入cmd

![image-20210331205034906](/image-20210331205034906.png)



2、输入命令：

```
git clone git@github.com:cfg1573/test_QY133.git
```



![image-20210331205114896](/image-20210331205114896.png)

回车 克隆完成

![image-20210331205228289](/image-20210331205228289.png)

克隆完成，文件下载至本地

![image-20210331205259962](/image-20210331205259962.png)

> 小结
> 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。
> Git支持多种协议，包括https，但ssh协议速度最快。



# 6、分支的概念

分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。
如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！

![fz240](/fz240.png)



分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。

现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。



![image-20210331210521460](/image-20210331210521460.png)



> 注意，从远程仓库克隆下项目后，我们需要在分支上进行代码编写，不能直接在主分支上进行修改



# 7、分支操作

#### 1、gitHub新建一个远程仓库，在本地克隆

![image-20210331211131541](/image-20210331211131541.png)



![image-20210331211251887](/image-20210331211251887.png)

克隆成功：

<img src="/image-20210331211808015.png" alt="image-20210331211808015" style="zoom:80%;border:1px solid #999" />



#### 2、在克隆成功的项目下，查看分支：



##### 查看分支：git branch

<img src="/image-20210331212056247.png" alt="image-20210331212056247" style="zoom:80%;border:1px solid #999" />



##### 创建分支：git branch 分支名

<img src="/image-20210331212359409.png" alt="image-20210331212359409" style="zoom:80%;border:1px solid #999;padding:5px" />



创建了一个dev分支，dev是devlop的缩写，表示开发分支

我们接下来的程序会写在dev分支上，写完以后再合并到主分支中





#### 切换分支：

```
git switch name或者git checkout name  name表示分支名
```

<img src="/image-20210331212849597.png" alt="image-20210331212849597" style="zoom:80%;border:1px solid #999;padding:5px" />

#### 创建+切换分支

```
git switch -c name或者git checkout -b name
```

#### 合并某分支到当前分支：

如果要把dev分支合并到master 需要先切换到master分支，因为合并是要把分支合并到当前分支

```
git merge name
```

例：

在dev分支下新建index.html,index.css，

<img src="/image-20210331213718405.png" alt="image-20210331213718405" style="zoom:80%;border:1px solid #999;padding:5px" />

添加，提交

<img src="/image-20210331213850970.png" alt="image-20210331213850970" style="zoom:80%;border:1px solid #999;padding:5px" />

然后切换到主分支，此时主分支中没有新提交的index.html文件

<img src="/image-20210331214224937.png" alt="image-20210331214224937" style="zoom:80%;border:1px solid #999;padding:5px" />



合并分支， git merge dev ,这样就把dev分支的内容提交到了主分支下面

<img src="/image-20210331214451794.png" alt="image-20210331214451794" style="zoom:80%;border:1px solid #999;padding:5px" />





#### 删除分支：git branch -d name

我们用过以后的分支，如果不想用了可以删掉

![image-20210331214758480](/image-20210331214758480.png)



#### 3、解决冲突

当多个分支同时修改同一处代码时（同一个文件时），合并时就会出现冲突的情况



如：

在dev分支中修改index.html,修改，提交

![image-20210331220608431](/image-20210331220608431.png)

dev分支修改：

<img src="/image-20210331220907185.png" alt="image-20210331220907185" style="zoom:80%;border:1px solid #999;padding:5px" />



切换到main分支，继续修改index.html，修改，提交

<img src="/image-20210331221322848.png" alt="image-20210331221322848" style="zoom:80%;border:1px solid #999;padding:5px" />

合并dev分支到main分支中，此时就会出现冲突

<img src="/image-20210331221550433.png" alt="image-20210331221550433" style="zoom:80%;border:1px solid #999;padding:5px" />



两个分支同时修改一个文件，git不知道要使用哪一次提交

Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，

解决方法，手动更改

<img src="/image-20210331222048117.png" alt="image-20210331222048117" style="zoom:80%;border:1px solid #999;padding:5px" />

如：点击保留双方更改

<img src="/C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210331222229594.png" alt="image-20210331222229594" style="zoom: 80%; border: 1px solid rgb(153, 153, 153); padding: 5px;" />

点击后再次添加、提交

<img src="/image-20210331222347843.png" alt="image-20210331222347843" style="zoom:80%;border:1px solid #999;padding:5px" />



#### 4、查看分支情况



**git log也可以看到分支的合并情况**



![image-20210331222815337](/image-20210331222815337.png)



**git log --graph命令可以看到分支合并图**

![image-20210331222943281](/image-20210331222943281.png)



# 8、分支策略

在实际开发中，我们应该按照几个基本原则进行分支管理：

首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；

那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；

你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。
所以，团队合作的分支看起来就像这样：



![img](/---0.png)





# 9、多人协作

管理员先在远程仓库创建好仓库，并建立好相关分支，比如master分支，dev分支



![image-20210331235536136](/image-20210331235536136.png)



建A,B两个文件夹，代表另个程序员进行克隆



![image-20210401000049404](/image-20210401000049404.png)



要查看远程库的信息，用 git remote
用 git remote -v 显示更详细的信息

![image-20210401000830741](/image-20210401000830741.png)



当团队成员从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。

> git push -u origin master //向远程仓库origin 的master 分支提交代码
> git pull origin master //拉取远程仓库origin 的master 分支的代码



要查看远程库的信息，用 git remote
用 git remote -v 显示更详细的信息

当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看

![image-20210401000919368](/image-20210401000919368.png)

现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支和远程仓库的分支连接起来：

> git checkout -b dev origin/dev
> //等同于一下多个命令合并使用 创建一个dev分支并切换到dev分支下，同时和远程仓库的dev关联起来
>
> git branch dev //新建分支
> git checkout dev //切换分支
>  //没有把本地的dev分支与远程的dev分支关联起来，此时是没有拉去数据的

<img src="/image-20210401001038583.png" alt="image-20210401001038583" style="zoom:80%;border:1px solid #999;padding:5px" />



现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：

在dev分支新建一个index.html.，添加 提交

<img src="/image-20210401001416613.png" alt="image-20210401001416613" style="zoom:80%;border:1px solid #999;padding:5px" />



![image-20210401001514620](/image-20210401001514620.png)





多人协作时，大家都会往master和dev分支上推送各自的修改。但是一般master是稳定的只是用来发布新版本分支，工作干活的分支是dev分支，一般团队成员只会提交dev分支。



# 10、推送分支

推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：

> git push origin master



如果要推送其他分支，比如dev，就改成：

> git push origin dev



但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？

- master分支是主分支，因此要时刻与远程同步；
  - dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；
- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；
- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。



你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：



**b同学也来进行提交，出现冲突**

![image-20210401002010670](/C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210401002010670.png)



解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：

> git pull origin dev



冲突的文件：



手动解决冲突：再次提交

![image-20210401002901062](/C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210401002901062.png)



![image-20210401002953952](/image-20210401002953952.png)





git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push

dev分支有内容：

![image-20210401003131098](/image-20210401003131098.png)

main分支下什么也没有，因为没有合并：

![image-20210401003216212](/image-20210401003216212.png)



使用github解决远程仓库合并：

![image-20210401003304834](/image-20210401003304834.png)



![image-20210401003518339](/image-20210401003518339.png)

![image-20210401003910197](/image-20210401003910197.png)



![image-20210401004008516](/image-20210401004008516.png)





> git branch --set-upstream-to=origin/dev dev



因此，多人协作的工作模式通常是这样：

1. 从远程克隆仓库到本地
2. 拉取建立本地开发dev分支并常规开发
3. 用git push origin <branch-name>推送自己的修改；
4. 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；
5. 如果合并有冲突，则解决冲突，并在本地提交；
6. 没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！
7. 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to <branch-name> origin/<branch-name>。